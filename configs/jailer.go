package configs

import (
	"fmt"
	"open-fire/utils"
	"os"
	"path/filepath"
	"strings"
)

// ChrootBaseMaxLength is the maximum length of the chroot base setting.
//
// This limitation is dictated but the Kernel socket path maxmimum length set to 107 characters + zero terminator.
//
// The constant jailer path suffix used by firebuild is 76 characters:
//
// - constant /firecracker-v0.22.4-x86_64/ (automatically generated by the jailer)
// - VMM ID is always 20 characters long
// - constant /root/run/firecracker.socket assumed by the jailer
//
// Example: /firecracker-v0.22.4-x86_64/sifuqm4rq2runxparjcx/root/run/firecracker.socket.
//
// Using more than 31 characters for the --chroot-base value, regardless if in the profile setting or using the command --chroot-base flag, will lead to a very obscure error.
const ChrootBaseMaxLength = 31

// JailingFirecrackerConfig represents Jailerspecific configuration options.
type JailingFirecrackerConfig struct {
	binaryFirecracker string `description:"Path to the Firecracker binary to use"`
	BinaryJailer      string `json:"BinaryJailer" mapstructure:"BinaryJailer" description:"Path to the Jailer binary to use"`
	ChrootBase        string `json:"ChrootBase" mapstructure:"ChrootBase" description:"chroot base directory; can't be empty or /"`

	JailerGID      int `json:"JailerGid" mapstructure:"JailerGid" description:"Jailer GID value"`
	JailerNumeNode int `json:"JailerNumaNode" mapstructure:"JailerNumaNode" description:"Jailer NUMA node"`
	JailerUID      int `json:"JailerUid" mapstructure:"JailerUid" description:"Jailer UID value"`

	NetNS string `json:"NetNS" mapstructure:"NetNS" description:"Network namespace"`

	vmmID string
}

// NewJailingFirecrackerConfig returns a new instance of the configuration.
func NewJailingFirecrackerConfig() *JailingFirecrackerConfig {

	cfg := &JailingFirecrackerConfig{
		vmmID:             "",
		binaryFirecracker: "/usr/bin/firecracker",
		BinaryJailer:      "/usr/bin/jailer",
		ChrootBase:        "/srv/jailer",
		JailerGID:         0,
		JailerNumeNode:    0,
		JailerUID:         0,
		NetNS:             "/var/lib/netns",
	}
	return cfg.ensure()
}

func NewJailingFirecrackerConfigWithChrootBase(ChrootBase string) (*JailingFirecrackerConfig, error) {
	cfg := NewJailingFirecrackerConfig()

	if ChrootBase == "" {
		return nil, fmt.Errorf("chroot base parameter is missing")
	}

	cfg.ChrootBase = ChrootBase

	return cfg, nil
}

// JailerChrootDirectory returns a full path to the jailer configuration directory.
// This method will return empty string until the flag set returned by FlagSet() is parsed.
func (c *JailingFirecrackerConfig) JailerChrootDirectory() string {

	return filepath.Join(c.ChrootBase,
		filepath.Base(c.BinaryFirecracker()), c.VMMID())
}

// VMMID returns a configuration instance unique VMM ID.
func (c *JailingFirecrackerConfig) VMMID() string {
	return c.vmmID
}

// Validate validates the correctness of the configuration.
func (c *JailingFirecrackerConfig) Validate() error {
	if c.ChrootBase == "" || c.ChrootBase == "/" {
		return fmt.Errorf("--chroot-base must be set to value other than empty and /")
	}
	if len(c.ChrootBase) > ChrootBaseMaxLength {
		return fmt.Errorf("--chroot-base must cannot be longer than %d characters", ChrootBaseMaxLength)
	}
	return nil
}

// WithVMMID allows overriding the VMM ID.
func (c *JailingFirecrackerConfig) WithVMMID(input string) *JailingFirecrackerConfig {
	c.vmmID = input
	return c
}

func (c *JailingFirecrackerConfig) ensure() *JailingFirecrackerConfig {
	if c.vmmID == "" {
		c.vmmID = strings.ToLower(utils.RandStringWithDigitsBytes(20))
	}
	return c
}

// SocketPathIfExists fetches the VMM socket path.
// Returns the socket path, a boolean indicating if the socket exists and an error if existence check went wrong.
func (c *JailingFirecrackerConfig) SocketPathIfExists() (string, bool, error) {
	socketPath := filepath.Join(c.ChrootBase, filepath.Base(c.BinaryFirecracker()), c.vmmID, "root", "run", "firecracker.socket")
	hasSocket, existsErr := utils.PathExists(socketPath)
	return socketPath, hasSocket, existsErr
}

func (c *JailingFirecrackerConfig) BinaryFirecracker() string {
	firecrackerPath, err := os.Readlink(c.binaryFirecracker)

	if err != nil {
		firecrackerPath = c.binaryFirecracker
	}

	return firecrackerPath
}
